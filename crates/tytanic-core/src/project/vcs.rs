//! Types for version control system (VCS) support.
//!
//! VCS support is used for generation of temporary artifacts and test output.
//! When Tytanic is used within a Git repository for example, the temporary
//! artifacts should most likely not be tracked by Git. The [`Vcs`] type
//! provides and interface for ignoring directories in multiple VCS'. Tytanic
//! supports Git, Jujutsu and Sapling through `.gitignore` files and Mercurial
//! through its root `.hgignore` file.
//!
//! # Examples
//! To ignore a directory in a git repository all that is needed is a [`Vcs`]
//! instance with [`Kind::Git`] and a path to the directory from the root of the
//! repository.
//! ```no_run
//! # use tytanic_core::project::vcs::Kind;
//! # use tytanic_core::project::vcs::Vcs;
//! let root = "/home/user/src/my-package";
//!
//! // creates /home/user/src/my-package/.gitignore
//! Vcs::new(root, Kind::Git).ignore_directory("build")?;
//! # Ok::<_, Box<dyn std::error::Error>>(())
//! ```

use std::fs;
use std::io;
use std::path::Path;
use std::path::PathBuf;

use thiserror::Error;

/// The content of the generated inner git ignore file.
const INNER_GITIGNORE_CONTENT: &str = "# generated by tytanic, do not edit\n*\n";

/// The supported set of version control systems.
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Kind {
    /// The git VCS.
    #[default]
    Git,

    /// A git-compatible VCS developed at Meta.
    Sapling,

    /// A git-compatible VCS.
    Jujutsu,

    /// The Mercurial VCS.
    Mercurial,
}

impl Kind {
    /// The ignore filename used by this VCS.
    ///
    /// # Examples
    /// ```
    /// # use tytanic_core::project::vcs::Kind;
    /// assert_eq!(Kind::Git.ignore_filename(), ".gitignore");
    /// assert_eq!(Kind::Mercurial.ignore_filename(), ".hgignore");
    /// ```
    pub fn ignore_filename(&self) -> &'static str {
        match self {
            Self::Git | Self::Sapling | Self::Jujutsu => ".gitignore",
            Self::Mercurial => ".hgignore",
        }
    }
}

/// A version control system, this is used to ignore temporary artifacts.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Vcs {
    root: Option<PathBuf>,
    kind: Kind,
}

impl Vcs {
    /// Creates a new VCS with the given root directory and kind.
    ///
    /// The root directory is that of the VCS repository, which may match that
    /// of the associated project.
    pub fn new<I>(root: I, kind: Kind) -> Self
    where
        I: Into<PathBuf> + AsRef<Path>,
    {
        debug_assert!(root.as_ref().is_absolute(), "root must be absolute");

        Self {
            root: Some(root.into()),
            kind,
        }
    }

    /// Creates a new VCS with the given kind and no root.
    pub fn new_rootless(kind: Kind) -> Self {
        Self { root: None, kind }
    }

    /// Tries to infer the VCS for the given VCS root directory.
    ///
    /// Returns `None` if there is no known hidden VCS directory (such as
    /// `.git`, `.hg`, etc.).
    ///
    /// # Errors
    /// May return errors if `root` or its sub directories are inaccessible.
    ///
    /// # Examples
    /// ```no_run
    /// # use tytanic_core::project::vcs::Kind;
    /// # use tytanic_core::project::vcs::Vcs;
    /// let vcs = Vcs::try_infer_kind("/home/user/src/my-package")?;
    /// assert_eq!(vcs, Some(Kind::Git));
    ///
    /// let vcs = Vcs::try_infer_kind("/home/user/src")?;
    /// assert_eq!(vcs, None);
    /// # Ok::<_, Box<dyn std::error::Error>>(())
    /// ```
    pub fn try_infer_kind<P>(root: P) -> io::Result<Option<Kind>>
    where
        P: AsRef<Path>,
    {
        fn inner(root: &Path) -> io::Result<Option<Kind>> {
            let mut root = root.to_path_buf();

            // Sapling and Jujutsu are both git compatible and may exist
            // alongside a `.git` directory, so we need to look for them first.
            // After this we check for `.git` first, because it is by far the
            // most common version control system.

            let mut inferred = None;
            for (dir, kind) in [
                (".jj", Kind::Jujutsu),
                (".sl", Kind::Sapling),
                (".git", Kind::Git),
                (".hg", Kind::Mercurial),
            ] {
                root.push(dir);
                if root.try_exists()? {
                    inferred = Some(kind);
                    root.pop();
                    break;
                }
                root.pop();
            }

            Ok(inferred)
        }

        inner(root.as_ref())
    }
}

impl Vcs {
    /// The root of this VCS repository.
    pub fn root(&self) -> Option<&Path> {
        self.root.as_deref()
    }

    /// The kind of this repository.
    pub fn kind(&self) -> Kind {
        self.kind
    }
}

impl Vcs {
    /// Ignores the given directory in accordance to this VCS.
    ///
    /// For **Git-compatible** VCS a new `.gitignore` file is written into the
    /// directory with the `*` pattern.
    ///
    /// For **Mercurial** the root file is modified if it does not yet contain a
    /// suitable pattern for the directory. This is done on a best-effort
    /// basis, if a user modifies the pattern or uses another pattern that
    /// matches the directory, then it will add the pattern again.
    ///
    /// # Panics
    /// Panics if:
    /// - the directory cannot be converted into UTF-8.
    /// - it isn't an absolute path.
    /// - it isn't inside the VCS root.
    ///
    /// # Errors
    /// Returns an error if the VCS has no root set.
    ///
    /// # Examples
    /// ```no_run
    /// # use tytanic_core::project::vcs::Kind;
    /// # use tytanic_core::project::vcs::Vcs;
    /// let root = "/home/user/src/my-package";
    ///
    /// // creates /home/user/src/my-package/.gitignore
    /// Vcs::new(root, Kind::Git).ignore_directory("build")?;
    /// # Ok::<_, Box<dyn std::error::Error>>(())
    /// ```
    pub fn ignore_directory<P>(&self, dir: P) -> Result<(), IgnoreDirectoryError>
    where
        P: AsRef<Path>,
    {
        fn inner(vcs: &Vcs, dir: &Path) -> Result<(), IgnoreDirectoryError> {
            assert!(dir.is_absolute());

            match vcs.kind() {
                Kind::Git | Kind::Sapling | Kind::Jujutsu => {
                    fs::write(dir.join(".gitignore"), INNER_GITIGNORE_CONTENT)?;
                }
                Kind::Mercurial => {
                    let Some(root) = vcs.root() else {
                        return Err(IgnoreDirectoryError::MercurialMissingRoot {
                            dir: dir.to_path_buf(),
                        });
                    };

                    let Ok(dir) = dir.strip_prefix(root) else {
                        panic!("{dir:?} is not in {root:?}");
                    };

                    let Some(pattern) = dir.to_str() else {
                        panic!("couldn't turn {dir:?} into UTF-8");
                    };

                    let mut pattern = if std::path::MAIN_SEPARATOR == '\\' {
                        format!("rootglob:{}", pattern.replace('\\', "/"))
                    } else {
                        format!("rootglob:{pattern}")
                    };

                    pattern.push('/');

                    let path = root.join(".hgignore");

                    let content = fs::read_to_string(&path)?;

                    if content.lines().any(|line| line.trim() == pattern) {
                        return Ok(());
                    }

                    let mut buf = String::with_capacity(content.len() + pattern.len() + 2);
                    content.clone_into(&mut buf);

                    if !buf.ends_with('\n') {
                        buf.push('\n');
                    }

                    buf.push_str(pattern.as_ref());
                    buf.push('\n');

                    fs::write(&path, buf)?;
                }
            }

            Ok(())
        }

        inner(self, dir.as_ref())
    }
}

/// Returned by [`Vcs::ignore_directory`].
#[derive(Debug, Error)]
pub enum IgnoreDirectoryError {
    /// Attempted to ignore a directory without VCS root.
    #[error("attempted to ignore {dir:?} without VCS root")]
    MercurialMissingRoot {
        /// The directory that could not be ignored.
        dir: PathBuf,
    },

    /// An IO error occurred.
    #[error("an IO error occurred")]
    Io(#[from] io::Error),
}

#[cfg(test)]
mod tests {
    use tytanic_utils::fs::TempTestEnv;

    use super::*;

    #[test]
    fn test_sapling_detect_before_git() {
        TempTestEnv::run_no_check(
            |root| root.setup_dir(".sl").setup_dir(".git"),
            |root| {
                let kind = Vcs::try_infer_kind(root).unwrap().unwrap();
                assert_eq!(kind, Kind::Sapling);
            },
        );
    }

    #[test]
    fn test_jujutsu_detect_before_git() {
        TempTestEnv::run_no_check(
            |root| root.setup_dir(".jj").setup_dir(".git"),
            |root| {
                let kind = Vcs::try_infer_kind(root).unwrap().unwrap();
                assert_eq!(kind, Kind::Jujutsu);
            },
        );
    }

    #[test]
    fn test_git_detect() {
        TempTestEnv::run_no_check(
            |root| root.setup_dir(".git"),
            |root| {
                let kind = Vcs::try_infer_kind(root).unwrap().unwrap();
                assert_eq!(kind, Kind::Git);
            },
        );
    }

    #[test]
    fn test_hg_detect() {
        TempTestEnv::run_no_check(
            |root| root.setup_dir(".hg"),
            |root| {
                let kind = Vcs::try_infer_kind(root).unwrap().unwrap();
                assert_eq!(kind, Kind::Mercurial);
            },
        );
    }

    #[test]
    fn test_git_ignore_create() {
        TempTestEnv::run(
            |root| root.setup_dir("tests/fancy/out"),
            |root| {
                let vcs = Vcs::new(root, Kind::Git);
                vcs.ignore_directory(root.join("tests/fancy/out")).unwrap();
            },
            |root| root.expect_file_content("tests/fancy/out/.gitignore", INNER_GITIGNORE_CONTENT),
        );
    }

    #[test]
    fn test_git_ignore_truncate() {
        TempTestEnv::run(
            |root| root.setup_file("tests/fancy/out/.gitignore", "foo"),
            |root| {
                let vcs = Vcs::new(root, Kind::Git);
                vcs.ignore_directory(root.join("tests/fancy/out")).unwrap();
            },
            |root| root.expect_file_content("tests/fancy/out/.gitignore", INNER_GITIGNORE_CONTENT),
        );
    }

    #[test]
    fn test_hg_ignore_amend() {
        TempTestEnv::run(
            |root| {
                root.setup_dir("tests/fancy/out")
                    .setup_file(".hgignore", "tests/other\n")
            },
            |root| {
                let vcs = Vcs::new(root, Kind::Mercurial);
                vcs.ignore_directory(root.join("tests/fancy/out")).unwrap();
            },
            |root| {
                root.expect_dir("tests/fancy/out")
                    .expect_file_content(".hgignore", "tests/other\nrootglob:tests/fancy/out/\n")
            },
        );
    }

    #[test]
    fn test_hg_ignore_unchanged() {
        TempTestEnv::run(
            |root| {
                root.setup_dir("tests/fancy/out")
                    .setup_file(".hgignore", "rootglob:tests/fancy/out/")
            },
            |root| {
                let vcs = Vcs::new(root, Kind::Mercurial);
                vcs.ignore_directory(root.join("tests/fancy/out")).unwrap();
            },
            |root| {
                root.expect_dir("tests/fancy/out")
                    .expect_file_content(".hgignore", "rootglob:tests/fancy/out/")
            },
        );
    }
}
