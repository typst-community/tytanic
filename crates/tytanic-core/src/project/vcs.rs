//! Version control support.
//!
//! This is used in a project to ensure that ephemeral storage directories are
//! not managed by the VCS of the user. Currently supports `.gitignore` and
//! `.hgignore` based VCS' as well as auto discovery of Git, Mercurial and
//! Jujutsu through their hidden repository directories.

use std::fmt;
use std::fmt::Debug;
use std::fmt::Display;
use std::fs;
use std::io;
use std::path::Path;
use std::path::PathBuf;

use super::Project;
use crate::test::UnitTest;

/// The name of the git ignore file.
const GITIGNORE_NAME: &str = ".gitignore";

/// The name of the mercurial ignore file.
const HGIGNORE_NAME: &str = ".hgignore";

/// The content of the generated git ignore file.
const IGNORE_HEADER: &str = "# generated by tytanic, do not edit";

/// The kind of [`Vcs`] in use.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Kind {
    /// Uses `.gitignore` files to ignore temporary files and directories.
    ///
    /// This means it can also be used by VCS's which support `.gitignore` files,
    /// like Jujutsu.
    Git,

    /// Uses `.hgignore` files to ignore temporary files and directories.
    ///
    /// This means it can also be used by Vcs' which support `.hgignore` files.
    Mercurial,
}

/// A version control system, this is used to handle persistent storage of
/// reference images and ignoring of non-persistent directories like the `out`
/// and `diff` directories.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Vcs {
    root: Option<PathBuf>,
    kind: Kind,
}

impl Vcs {
    /// Creates a new VCS with the given root directory and kind.
    pub fn new<I>(root: I, kind: Kind) -> Self
    where
        I: Into<PathBuf>,
    {
        Self {
            root: Some(root.into()),
            kind,
        }
    }

    /// Creates a new VCS with the given kind and no root.
    pub fn new_rootless(kind: Kind) -> Self {
        Self { root: None, kind }
    }

    /// Checks the given directory for a VCS root, returning which kind was
    /// found.
    #[tracing::instrument(ret)]
    pub fn exists_at(dir: &Path) -> io::Result<Option<Kind>> {
        if dir.join(".git").try_exists()? || dir.join(".jj").try_exists()? {
            return Ok(Some(Kind::Git));
        }

        if dir.join(".hg").try_exists()? {
            return Ok(Some(Kind::Mercurial));
        }

        Ok(None)
    }
}

impl Vcs {
    /// The root of this Vcs' repository.
    pub fn root(&self) -> Option<&Path> {
        self.root.as_deref()
    }

    /// The kind of this repository.
    pub fn kind(&self) -> Kind {
        self.kind
    }

    /// Ignore all ephemeral files and directories of a test.
    #[tracing::instrument(skip(project, test), fields(test = ?test.id()))]
    pub fn ignore(&self, project: &Project, test: &UnitTest) -> io::Result<()> {
        let mut content = format!("{IGNORE_HEADER}\n\n");

        let file = project.unit_test_dir(test.id()).join(match self.kind {
            Kind::Git => GITIGNORE_NAME,
            Kind::Mercurial => {
                content.push_str("syntax: glob\n");
                HGIGNORE_NAME
            }
        });

        for always in ["/diff/\n", "/out/\n"] {
            content.push_str(always);
        }

        if !test.kind().is_persistent() {
            content.push_str("/ref/\n");
        }

        fs::write(file, content)?;

        Ok(())
    }

    #[tracing::instrument(skip(project, test), fields(test = ?test.id()))]
    pub fn unignore(&self, project: &Project, test: &UnitTest) -> io::Result<()> {
        let file = project.unit_test_dir(test.id()).join(match self.kind {
            Kind::Git => GITIGNORE_NAME,
            Kind::Mercurial => HGIGNORE_NAME,
        });

        fs::remove_file(file)
    }
}

impl Display for Vcs {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.pad(match self.kind {
            Kind::Git => "Git",
            Kind::Mercurial => "Mercurial",
        })
    }
}

#[cfg(test)]
mod tests {
    use tytanic_utils::fs::TempTestEnv;

    use super::*;
    use crate::project::Project;
    use crate::test::unit::Kind as TestKind;
    use crate::test::Id;

    fn test(kind: TestKind) -> UnitTest {
        UnitTest::new_test(Id::new("fancy").unwrap(), kind)
    }

    #[test]
    fn test_git_ignore_create() {
        TempTestEnv::run(
            |root| root.setup_dir("tests/fancy"),
            |root| {
                let project = Project::new(root);
                let vcs = Vcs::new(root, Kind::Git);
                let test = test(TestKind::CompileOnly);
                vcs.ignore(&project, &test).unwrap();
            },
            |root| {
                root.expect_dir("tests/fancy").expect_file_content(
                    "tests/fancy/.gitignore",
                    format!("{IGNORE_HEADER}\n\n/diff/\n/out/\n/ref/\n"),
                )
            },
        );
    }

    #[test]
    fn test_git_ignore_truncate() {
        TempTestEnv::run(
            |root| root.setup_file("tests/fancy/.gitignore", "blah blah"),
            |root| {
                let project = Project::new(root);
                let vcs = Vcs::new(root, Kind::Git);
                let test = test(TestKind::CompileOnly);
                vcs.ignore(&project, &test).unwrap();
            },
            |root| {
                root.expect_dir("tests/fancy").expect_file_content(
                    "tests/fancy/.gitignore",
                    format!("{IGNORE_HEADER}\n\n/diff/\n/out/\n/ref/\n"),
                )
            },
        );
    }

    #[test]
    fn test_git_unignore() {
        TempTestEnv::run(
            |root| root.setup_file("tests/fancy/.gitignore", "blah blah"),
            |root| {
                let project = Project::new(root);
                let vcs = Vcs::new(root, Kind::Git);
                let test = test(TestKind::CompileOnly);
                vcs.unignore(&project, &test).unwrap();
            },
            |root| root.expect_dir("tests/fancy"),
        );
    }
}
